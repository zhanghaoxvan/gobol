#include <AST/ASTBuilder.hpp>
#include <AST/ASTPrinter.hpp>
#include <Bytecode/Compiler.hpp>
#include <Bytecode/OpCode.hpp>
#include <Bytecode/RuntimeValue.hpp>
#include <Bytecode/VirtualMachine.hpp>
#include <Environment/SemanticAnalyzer.hpp>
#include <Lexer/Lexer.hpp>
#include <fstream>
#include <iostream>
#include <sstream>
#include <sys/types.h>
#include <unistd.h>

std::string getSource(const std::string &file) {
    std::ifstream ifs(file, std::ios::binary); // 以二进制模式打开

    // 检查文件是否成功打开
    if (!ifs.is_open()) {
        std::cerr << "Error: Cannot open file '" << file << "'" << std::endl;
        return "";
    }

    // 读取整个文件
    std::stringstream buf;
    buf << ifs.rdbuf();
    std::string source = buf.str();

    return source;
}
int main(int argc, char *argv[]) {

    if (argc == 1) {
        std::cout << "Usage:" << std::endl;
        std::cout << "  " << argv[0] << " <filename>" << std::endl;
        return 0;
    }

    std::string source = getSource(argv[1]);

    lexer::Lexer lexer(source);
    auto tk = lexer.getNextToken();
#ifdef DEBUG
    std::cout << "===== Step 0: Reprint Source =====" << std::endl;
    std::cout << source << std::endl;
    std::cout << "===== Step 1: Tokenize =====" << std::endl;
    while (tk.type != lexer::token::TokenType::END_OF_FILE) {
        std::cout << "Token(Type=" << lexer::token::tokenTypeToString(tk.type) << ", Val='"
                  << (tk.value == "\n" ? "\\n" : tk.value) << "')" << std::endl;
        tk = lexer.getNextToken();
    }
    std::cout << std::endl << std::endl;
    std::cout << "======= Step 2: AST =======" << std::endl;
#endif
    lexer.resetPosition();
    AST::ASTBuilder builder(lexer);
    AST::Program *prog = builder.build();
    if (builder.hasError()) {
        for (const auto &msg : builder.getErrorMessage()) {
            std::cerr << "Builder Error: " << msg << std::endl;
        }
        return 1;
    }
#ifdef DEBUG
    AST::ASTPrinter printer;
    printer.visit(prog);
    std::cout << std::endl << std::endl;
    std::cout << "======= Step 3: Semantic Analysis =======" << std::endl;
#endif

    analyzer::SemanticAnalyzer semanticAnalyzer;
    bool semanticPassed = semanticAnalyzer.analyze(prog);
    if (!semanticPassed) {
        return 1;
    }
#ifdef DEBUG
    std::cout << std::endl << std::endl;
    std::cout << "======= Step 4: Compile to OpCode =======" << std::endl;
#endif
    vm::Compiler compiler;
    vm::BytecodeModule *module = compiler.compile(prog);
    auto opCodes = compiler.getOpCodes();
    if (!module) {
        std::cerr << "Compilation failed!" << std::endl;
        return 1;
    }
#ifdef DEBUG
    std::cout << "\nGenerated bytecode:" << std::endl;
    module->dump();
    std::cout << std::endl << std::endl;
    // return 0;
    std::cout << "======= Step 5: Virtual Machine =======" << std::endl;
#endif
    vm::VirtualMachine vm;
    bool success = vm.run(module); // 传 module，不是 opCodes

    if (!success) {
        std::cerr << "Program execution failed!" << std::endl;
    }
    return !success;
}
